@inject IStateSelection<AppState, Note?> EditingNoteSelector
@inject IStateSelection<AppState, bool> ShowCreateDialogSelector

<MudDialog Visible="Note != null || ShowCreateDialogSelector.Value"
           VisibleChanged="HandleVisibleChanged"
           Options="_options"
           DefaultFocus="DefaultFocus.FirstChild">
    <TitleContent>
        @if (ShowCreateDialogSelector.Value)
        {
            @:Create note
        }
        else
        {
            @:Edit note
        }
    </TitleContent>
    <DialogContent>
        <MudStack>
            @* immediate is needed to also support the OnKeyUp submit *@
            <MudTextField @bind-Value="_newText"
                          Label="Text"
                          Lines="3"
                          AutoGrow="true"
                          Variant="Variant.Outlined"
                          Immediate="true"
                          OnKeyUp="HandleKeyUp"/>
            @if (Note != null)
            {
                @* no spacing here *@
                <MudStack Spacing="0">
                    <TimestampRenderer Timestamp="Note.CreatedAt" Prefix="Created:"/>
                    <TimestampRenderer Timestamp="Note.ModifiedAt" Prefix="Modified:"/>
                    <TimestampRenderer Timestamp="Note.ArchivedAt" Prefix="Archived:"/>
                    <TimestampRenderer Timestamp="Note.DeletedAt" Prefix="Trashed:"/>
                </MudStack>
            }
        </MudStack>
    </DialogContent>
    <DialogActions>
        @if (Note != null)
        {
            // use two spacers so the "second prio" actions are a little bit separated from Save+Cancel
            // but also not too much at the left edge
            <MudSpacer/>

            @if (Note.DeletedAt.HasValue)
            {
                <MudButton Color="Color.Primary"
                           OnClick="HandleRestoreFromTrash">
                    Restore from trash
                </MudButton>
            }
            else
            {
                <MudButton Color="Color.Warning"
                           OnClick="HandleTrash">
                    Trash
                </MudButton>
            }

            @if (Note.DeletedAt == null)
            {
                if (Note.ArchivedAt.HasValue)
                {
                    <MudButton Color="Color.Primary"
                               OnClick="HandleRestoreFromArchive">
                        Restore from archive
                    </MudButton>
                }
                else
                {
                    <MudButton Color="Color.Primary"
                               OnClick="HandleArchive">
                        Archive
                    </MudButton>
                }
            }

            <MudSpacer/>
        }
        <MudButton OnClick="HandleCancel">
            Cancel
        </MudButton>
        <MudButton Color="Color.Success"
                   OnClick="HandleSave">
            Save
        </MudButton>
    </DialogActions>
</MudDialog>

@code {

    string _newText = "";

    DialogOptions _options = new()
    {
        FullWidth = true, // full width of the MaxWidth setting
        BackdropClick = true,
        CloseOnEscapeKey = true
    };

    private Note? Note => EditingNoteSelector.Value;

    protected override void OnInitialized()
    {
// use an StateSelector so it does not rerender because of irrelevant changes
        // somebody could simplify this double-handling-thing, but actually I think that it has reached it's end already 
        EditingNoteSelector.Select(x => x.CurrentlyEditingNote);
        EditingNoteSelector.SelectedValueChanged += EditingNoteSelectorOnSelectedValueChanged;

        ShowCreateDialogSelector.Select(x => x.ShowCreateNoteDialog);
        ShowCreateDialogSelector.SelectedValueChanged += ShowCreateDialogSelectorOnSelectedValueChanged;

        base.OnInitialized();
    }

    private void EditingNoteSelectorOnSelectedValueChanged(object? sender, Note? e)
    {
        if (Note != null)
        {
            _newText = Note.Text;
        }
    }

    private void ShowCreateDialogSelectorOnSelectedValueChanged(object? sender, bool e)
    {
        if (ShowCreateDialogSelector.Value)
        {
// empty text when new edit starts
            _newText = "";
        }
    }

    private void HandleCancel()
    {
        if (ShowCreateDialogSelector.Value)
        {
            Dispatch(new NoteActions.HideCreateNoteDialogAction());
        }
        else
        {
            Dispatch(new NoteActions.CancelNoteEditingAction(Note!));
        }
    }

    private void HandleSave()
    {
        if (ShowCreateDialogSelector.Value)
        {
            Dispatch(new NoteActions.CreateNoteRequestAction(_newText));
        }
        else
        {
            Dispatch(new NoteActions.SaveNoteEditingAction(Note!, _newText));
        }
    }

    private void HandleVisibleChanged(bool isVisible)
    {
        // happens on backdrop click and ESC key
        if (!isVisible)
        {
            HandleCancel();
        }
    }

    private void HandleKeyUp(KeyboardEventArgs args)
    {
        if (args.CtrlKey && args.Key == "Enter") // todo extension method
        {
            HandleSave(); // todo check if _newText is updated
        }
    }

    private void HandleArchive()
    {
        Dispatch(new NoteActions.ArchiveNoteAction(Note!.Id));
        HandleSave(); // if the text was changed + to close the dialog
    }

    private void HandleRestoreFromArchive()
    {
        Dispatch(new NoteActions.RestoreNoteFromArchiveAction(Note!.Id));
        HandleSave(); // if the text was changed + to close the dialog
    }

    private void HandleTrash()
    {
        Dispatch(new NoteActions.TrashNoteAction(Note!.Id));
        HandleSave(); // if the text was changed + to close the dialog
    }

    private void HandleRestoreFromTrash()
    {
        Dispatch(new NoteActions.RestoreNoteFromTrashAction(Note!.Id));
        HandleSave(); // if the text was changed + to close the dialog
    }

}