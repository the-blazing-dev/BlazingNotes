@inject IStateSelection<AppState, Note?> EditingNoteSelector
@inject IStateSelection<AppState, bool> ShowCreateDialogSelector

<MudDialog Visible="Note != null || ShowCreateDialogSelector.Value"
           VisibleChanged="HandleVisibleChanged"
           Options="_options"
           DefaultFocus="DefaultFocus.FirstChild">
    <TitleContent>
        @if (ShowCreateDialogSelector.Value)
        {
            @:Create new note
        }
        else
        {
            @:Edit note
        }
    </TitleContent>
    <DialogContent>
        <MudStack>
            @* immediate is needed to also support the OnKeyUp submit *@
            <MudTextField @bind-Value="_newText"
                          Label="Text"
                          Lines="3"
                          AutoGrow="true"
                          Variant="Variant.Outlined"
                          Immediate="true"
                          OnKeyUp="HandleKeyUp"/>
            @if (Note != null)
            {
                @* no spacing here *@
                <MudStack Spacing="0">
                    <TimestampRenderer Timestamp="Note.CreatedAt" Prefix="Created:"/>
                    <TimestampRenderer Timestamp="Note.ModifiedAt" Prefix="Modified:"/>
                    <TimestampRenderer Timestamp="Note.ArchivedAt" Prefix="Archived:"/>
                    <TimestampRenderer Timestamp="Note.DeletedAt" Prefix="Trashed:"/>
                </MudStack>
            }
        </MudStack>
    </DialogContent>
    <DialogActions>
        @if (Note != null)
        {
            // use two spacers so the "second prio" actions are a little bit separated from Save+Cancel
            // but also not too much at the left edge
            <MudSpacer/>

            @* MudMenu is used as context menu *@
            <MudMenu ActivationEvent="MouseEvent.RightClick"
                     AnchorOrigin="Origin.TopCenter"
                     TransformOrigin="Origin.BottomCenter">
                <ActivatorContent>
                    @* we need to additionally check for null to prevent exception when dispatching the final delete *@
                    @if (Note != null)
                    {
                        @if (Note.DeletedAt.HasValue)
                        {
                            <MudButton Color="Color.Primary"
                                       OnClick="HandleRestoreFromTrash"
                                       accesskey="T"
                                       title="[accesskey + T]">
                                Restore from trash
                            </MudButton>
                        }
                        else
                        {
                            <MudButton Color="Color.Warning"
                                       OnClick="HandleTrash"
                                       accesskey="T"
                                       title="[accesskey + T]">
                                Trash
                            </MudButton>
                        }
                    }
                </ActivatorContent>
                <ChildContent>
                    @* here we define the secondary action *@
                    @* we pass the NoteId because the state will change in the meantime... *@
                    <MudMenuItem OnClick="() => HandleDeletePermanently(Note.Id)"
                                 Icon="@Icons.Material.Filled.DeleteForever"
                                 IconColor="Color.Error">
                        <MudText Color="Color.Error">
                            Delete permanently!
                        </MudText>
                    </MudMenuItem>
                </ChildContent>
            </MudMenu>

            @if (Note.DeletedAt == null)
            {
                if (Note.ArchivedAt.HasValue)
                {
                    <MudButton Color="Color.Primary"
                               OnClick="HandleRestoreFromArchive"
                               accesskey="A"
                               title="[accesskey + A]">
                        Restore from archive
                    </MudButton>
                }
                else
                {
                    <MudButton Color="Color.Primary"
                               OnClick="HandleArchive"
                               accesskey="A"
                               title="[accesskey + A]">
                        Archive
                    </MudButton>
                }
            }

            <MudSpacer/>
        }
        <MudButton OnClick="HandleCancel"
                   title="[Esc]">
            Cancel
        </MudButton>
        <MudButton Color="Color.Success"
                   OnClick="HandleSave"
                   Disabled="!_newText.HasContent()"
                   accesskey="S"
                   title="[accesskey + S]">
            Save
        </MudButton>
    </DialogActions>
</MudDialog>

@code {

    string _newText = "";

    DialogOptions _options = new()
    {
        FullWidth = true, // full width of the MaxWidth setting
        BackdropClick = true,
        CloseOnEscapeKey = true
    };

    private Note? Note => EditingNoteSelector.Value;

    protected override void OnInitialized()
    {
// use an StateSelector so it does not rerender because of irrelevant changes
        // somebody could simplify this double-handling-thing, but actually I think that it has reached it's end already 
        EditingNoteSelector.Select(x => x.CurrentlyEditingNote);
        EditingNoteSelector.SelectedValueChanged += EditingNoteSelectorOnSelectedValueChanged;

        ShowCreateDialogSelector.Select(x => x.ShowCreateNoteDialog);
        ShowCreateDialogSelector.SelectedValueChanged += ShowCreateDialogSelectorOnSelectedValueChanged;

        base.OnInitialized();
    }

    private void EditingNoteSelectorOnSelectedValueChanged(object? sender, Note? e)
    {
        if (Note != null)
        {
            _newText = Note.Text;
        }
    }

    private void ShowCreateDialogSelectorOnSelectedValueChanged(object? sender, bool e)
    {
        if (ShowCreateDialogSelector.Value)
        {
// empty text when new edit starts
            _newText = "";
        }
    }

    private void HandleCancel()
    {
        if (ShowCreateDialogSelector.Value)
        {
            Dispatch(new NoteActions.HideCreateNoteDialogAction());
        }
        else
        {
            Dispatch(new NoteActions.CancelNoteEditingAction(Note!));
        }
    }

    private void HandleSave()
    {
        if (ShowCreateDialogSelector.Value)
        {
            Dispatch(new NoteActions.CreateNoteRequestAction(_newText));
        }
        else
        {
            Dispatch(new NoteActions.SaveNoteEditingAction(Note!, _newText));
        }
    }

    private void HandleVisibleChanged(bool isVisible)
    {
        // happens on backdrop click and ESC key
        if (!isVisible)
        {
            HandleCancel();
        }
    }

    private void HandleKeyUp(KeyboardEventArgs args)
    {
        if (args.CtrlKey && args.Key == "Enter") // todo extension method
        {
            HandleSave(); // todo check if _newText is updated
        }
    }

    private void HandleArchive()
    {
        Dispatch(new NoteActions.ArchiveNoteAction(Note!.Id));
        HandleSave(); // if the text was changed + to close the dialog
    }

    private void HandleRestoreFromArchive()
    {
        Dispatch(new NoteActions.RestoreNoteFromArchiveAction(Note!.Id));
        HandleSave(); // if the text was changed + to close the dialog
    }

    private void HandleTrash()
    {
        Dispatch(new NoteActions.TrashNoteAction(Note!.Id));
        HandleSave(); // if the text was changed + to close the dialog
    }

    private void HandleRestoreFromTrash()
    {
        Dispatch(new NoteActions.RestoreNoteFromTrashAction(Note!.Id));
        HandleSave(); // if the text was changed + to close the dialog
    }

    private void HandleDeletePermanently(Guid noteId)
    {
        Dispatch(new NoteActions.DeleteNotePermanentlyAction(noteId));
// no other method call needed because CurrentlyEditingNote is cleared automatically by reducers
    }

}