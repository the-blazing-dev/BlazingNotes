@if (Timestamp.HasValue)
{
    const string space = " ";
    var classes = $"timestamp-renderer {Class}";
    <MudText Typo="Typo.body2" Class="@classes" title="@HoverTitle">
        <MudStack Row AlignItems="AlignItems.Baseline">
            @if (Prefix.HasContent())
            {
                <span class="prefix">@Prefix</span>
            }
            @if (Editable)
            {
                @* "Editable" to allow text input *@
                <MudDatePicker Date="Ts"
                               DateChanged="HandleDateChanged"
                               Editable
                               Class="date-picker flex-grow-0"/>
                <MudTimePicker Time="Ts.TimeOfDay"
                               TimeChanged="HandleTimeChanged"
                               Editable
                               Class="time-picker flex-grow-0"/>
            }
            else
            {
                if (Ts.Date != DateTime.Today)
                {
                    // only show date if it's not from today
                    @Ts.ToString("ddd,")
                    @space
                    @Ts.ToShortDateString()
                    @space
                }

                @Ts.ToShortTimeString()
            }
        </MudStack>
    </MudText>
}

@code {
    [Parameter] public DateTime? Timestamp { get; set; }
    [Parameter] public string? Prefix { get; set; }
    [Parameter] public string? Class { get; set; }
    [Parameter] public string? HoverTitle { get; set; }
    [Parameter] public bool Editable { get; set; }
    [Parameter] public EventCallback<DateTime> TimestampChanged { get; set; }

    private DateTime Ts => Timestamp.GetValueOrDefault().ToLocalTime();

    private Task HandleDateChanged(DateTime? arg)
    {
        if (arg.HasValue)
        {
            // we need to do "arg.Value.Date" because the change could come from:
            // 1) user editing the data -> no time portion
            // 2) rerendering / parameter setting -> including time portion
            var newValue = arg.Value.Date.Add(Ts.TimeOfDay);
            Timestamp = newValue; // to prevent jumping back to old value
            return TimestampChanged.InvokeAsync(newValue);
        }

        return Task.CompletedTask;
    }

    private Task HandleTimeChanged(TimeSpan? arg)
    {
        if (arg.HasValue)
        {
            var newDateTime = Ts.Date.Add(arg.Value);
            Timestamp = newDateTime; // to prevent jumping back to old value
            return TimestampChanged.InvokeAsync(newDateTime);
        }

        return Task.CompletedTask;
    }

}